{
  "contractName": "Locker",
  "latestAbiHash": "f59526398823aef0f0c1454d0b6b4eac",
  "deployedAbis": {
    "619ff7809b73aead28176fe6317953c3": {
      "latestDeployedAddress": "0x26438D7c52cE617dFc75A2F02eE816557f01e5Bb",
      "deployments": {
        "0x095c0f071fd75875a6b5a1def3f3a993f591080c": {
          "generatedAt": "2018-06-11T14:51:04.267Z",
          "truffleContractFileUpdatedAt": "2018-06-11T11:34:29.734Z",
          "deployTransactionHash": "0x9b36f058c0e32ea415ca2eae11b80dfa95d8fd0ee1a65dd5807b5e78d0f626f2",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "7b257e4c44f08fec5d6d5d2f9b09545b",
          "deployedBytecodeHash": "0cfd713f37d912355afd61f1f1f95aaa",
          "sourceHash": "786e07d17116d302210e391b40adc6ef",
          "source": "/* contract for tracking locked funds\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n  -> self-destruct function?\n\n*/\n\npragma solidity 0.4.24;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                            uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    event MonetarySupervisorChanged(MonetarySupervisor newMonetarySupervisor);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken,\n                    MonetarySupervisor _monetarySupervisor)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"StabilityBoard\") {\n\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId, \"lockProduct overflow\");\n        emit NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"StabilityBoard\") {\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n\n        lockProducts[lockProductId].isActive = isActive;\n        emit LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n        uint32 lockProductId = uint32(_lockProductId);\n        require(lockProductId == _lockProductId, \"lockProductId overflow\");\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function releaseFunds(uint lockId) external {\n        // next line would revert but require to emit reason:\n        require(lockId < locks.length, \"invalid lockId\");\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive, \"lock must be in active state\");\n        require(now >= lock.lockedUntil, \"current time must be later than lockedUntil\");\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        emit LockReleased(lock.owner, lockId);\n    }\n\n    function setMonetarySupervisor(MonetarySupervisor newMonetarySupervisor) external restrict(\"StabilityBoard\") {\n        monetarySupervisor = newMonetarySupervisor;\n        emit MonetarySupervisorChanged(newMonetarySupervisor);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, maxLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint[5][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs, lockProduct.minimumLockAmount,\n                        monetarySupervisor.getMaxLockAmount(lockProduct.minimumLockAmount, lockProduct.perTermInterest),\n                        lockProduct.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns CHUNK_SIZE locks starting from some offset\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locks.length) { break; }\n\n            Lock storage lock = locks[offset + i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [uint(offset + i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n    }\n\n    // returns CHUNK_SIZE locks of a given account, starting from some offset\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locks[locksForAddress[offset + i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [ locksForAddress[offset + i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).div(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal returns(uint lockId) {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive, \"lockProduct must be in active state\");\n        require(amountToLock >= lockProduct.minimumLockAmount, \"amountToLock must be >= minimumLockAmount\");\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration, \"lockedUntil overflow\");\n\n        lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        emit NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs);\n    }\n\n}\n"
        },
        "0x26438D7c52cE617dFc75A2F02eE816557f01e5Bb": {
          "generatedAt": "2018-07-08T13:53:52.504Z",
          "truffleContractFileUpdatedAt": "2018-07-08T13:01:58.928Z",
          "deployTransactionHash": "0xf35fab30788db2f107d1c7c54f28f3b97121d37f19a6a113a7b6c994d4645e56",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "2e46de94e61fb92a9f9c617a78c630a5",
          "deployedBytecodeHash": "5cf2a8e6d2fab15963890e142d3d15a3",
          "sourceHash": "0bc34f96859842d6cde3876ee878a209",
          "source": "/* contract for tracking locked funds\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n  -> self-destruct function?\n\n*/\n\npragma solidity 0.4.24;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                            uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    event MonetarySupervisorChanged(MonetarySupervisor newMonetarySupervisor);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken,\n                    MonetarySupervisor _monetarySupervisor)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"StabilityBoard\") {\n\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId, \"lockProduct overflow\");\n        emit NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"StabilityBoard\") {\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n\n        lockProducts[lockProductId].isActive = isActive;\n        emit LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n        uint32 lockProductId = uint32(_lockProductId);\n        require(lockProductId == _lockProductId, \"lockProductId overflow\");\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function releaseFunds(uint lockId) external {\n        // next line would revert but require to emit reason:\n        require(lockId < locks.length, \"invalid lockId\");\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive, \"lock must be in active state\");\n        require(now >= lock.lockedUntil, \"current time must be later than lockedUntil\");\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        emit LockReleased(lock.owner, lockId);\n    }\n\n    function setMonetarySupervisor(MonetarySupervisor newMonetarySupervisor) external restrict(\"StabilityBoard\") {\n        monetarySupervisor = newMonetarySupervisor;\n        emit MonetarySupervisorChanged(newMonetarySupervisor);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, maxLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint[5][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs, lockProduct.minimumLockAmount,\n                        monetarySupervisor.getMaxLockAmount(lockProduct.minimumLockAmount, lockProduct.perTermInterest),\n                        lockProduct.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns CHUNK_SIZE locks starting from some offset\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locks.length) { break; }\n\n            Lock storage lock = locks[offset + i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [uint(offset + i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n    }\n\n    // returns CHUNK_SIZE locks of a given account, starting from some offset\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locks[locksForAddress[offset + i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [ locksForAddress[offset + i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).ceilDiv(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal returns(uint lockId) {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive, \"lockProduct must be in active state\");\n        require(amountToLock >= lockProduct.minimumLockAmount, \"amountToLock must be >= minimumLockAmount\");\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration, \"lockedUntil overflow\");\n\n        lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        emit NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs);\n    }\n\n}\n"
        }
      }
    },
    "f59526398823aef0f0c1454d0b6b4eac": {
      "latestDeployedAddress": "0x5cc161482e82f20840a4aaeb582becbcc4b539d7",
      "deployments": {
        "0x5cc161482e82f20840a4aaeb582becbcc4b539d7": {
          "generatedAt": "2018-11-14T12:52:13.085Z",
          "truffleContractFileUpdatedAt": "2018-11-13T16:34:24.480Z",
          "deployTransactionHash": "0xffe69e16f5456cdf6b5288b7f423ac4b417b4e127d33ca4540867ee4fa12a736",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "0fe102ad0cf754658fdb075cb2850270",
          "deployedBytecodeHash": "211e0b56eb9155bf091df2937a90551d",
          "sourceHash": "5fb19771489eecebfa02e95214887146",
          "source": "/* contract for tracking locked funds\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n  -> self-destruct function?\n\n*/\n\npragma solidity 0.4.24;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                    uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    event MonetarySupervisorChanged(MonetarySupervisor newMonetarySupervisor);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken,\n                    MonetarySupervisor _monetarySupervisor)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"StabilityBoard\") {\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId, \"lockProduct overflow\");\n        emit NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"StabilityBoard\") {\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n\n        lockProducts[lockProductId].isActive = isActive;\n        emit LockProductActiveChange(lockProductId, isActive);\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        // next line would revert but require to emit reason:\n        require(_lockProductId < lockProducts.length, \"invalid lockProductId\");\n        uint32 lockProductId = uint32(_lockProductId);\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function releaseFunds(uint lockId) external {\n        // next line would revert but require to emit reason:\n        require(lockId < locks.length, \"invalid lockId\");\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive, \"lock must be in active state\");\n        require(now >= lock.lockedUntil, \"current time must be later than lockedUntil\");\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        emit LockReleased(lock.owner, lockId);\n    }\n\n    function setMonetarySupervisor(MonetarySupervisor newMonetarySupervisor) external restrict(\"StabilityBoard\") {\n        monetarySupervisor = newMonetarySupervisor;\n        emit MonetarySupervisorChanged(newMonetarySupervisor);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n        return lockProducts.length;\n    }\n\n    // returns <chunkSize> lock products starting from some <offset>\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, maxLockAmount, isActive ]\n    function getLockProducts(uint offset, uint16 chunkSize)\n    external view returns (uint[5][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), lockProducts.length);\n        uint[5][] memory response = new uint[5][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            LockProduct storage lockProduct = lockProducts[i];\n            response[i - offset] = [lockProduct.perTermInterest, lockProduct.durationInSecs, lockProduct.minimumLockAmount,\n                        monetarySupervisor.getMaxLockAmount(lockProduct.minimumLockAmount, lockProduct.perTermInterest),\n                        lockProduct.isActive ? 1 : 0 ];\n        }\n        return response;\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns <chunkSize> locks starting from some <offset>\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset, uint16 chunkSize)\n    external view returns (uint[8][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), locks.length);\n        uint[8][] memory response = new uint[8][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            Lock storage lock = locks[i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i - offset] = [uint(i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                        lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n        return response;\n    }\n\n    // returns <chunkSize> locks of a given account, starting from some <offset>\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset, uint16 chunkSize)\n    external view returns (uint[7][]) {\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n        uint limit = SafeMath.min(offset.add(chunkSize), locksForAddress.length);\n        uint[7][] memory response = new uint[7][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            Lock storage lock = locks[locksForAddress[i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i - offset] = [locksForAddress[i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                        lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n        return response;\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).ceilDiv(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive, \"lockProduct must be in active state\");\n        require(amountToLock >= lockProduct.minimumLockAmount, \"amountToLock must be >= minimumLockAmount\");\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration, \"lockedUntil overflow\");\n\n        uint lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        emit NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs);\n    }\n}\n"
        }
      }
    }
  }
}