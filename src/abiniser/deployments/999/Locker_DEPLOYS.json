{
  "contractName": "Locker",
  "latestAbiHash": "f59526398823aef0f0c1454d0b6b4eac",
  "deployedAbis": {
    "6055e2cba8c8e9cb7e04b10e4c56ab9a": {
      "latestDeployedAddress": "0x8fd4d02f46ec6c92924780d2bf35ae31078db9c5",
      "deployments": {
        "0x8fd4d02f46ec6c92924780d2bf35ae31078db9c5": {
          "generatedAt": "2018-04-25T12:29:07.651Z",
          "truffleContractFileUpdatedAt": "2018-02-14T23:29:32.229Z",
          "compiler": {
            "name": "solc",
            "version": "0.4.19+commit.c4cbbb05.Emscripten.clang"
          },
          "bytecodeHash": "66f7b66ff12fcb40830b0b95777fb852",
          "deployedBytecodeHash": "75adc582771c489bbe9ef06428e8e6cf",
          "sourceHash": "1135716bfcd72d7542f37f36acc8673e",
          "source": "/* contract for tracking locked funds etc.\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO:\n  - create  MonetarySupervisorInterface and use it instead of MonetarySupervisor\n  - monetarySupervisor setter?\n  - store locks in array so we can iterate over them\n\n to do/think about:\n  -> self-destruct function?\n  -> return only active loan products from getLoanProducts?\n*/\n\npragma solidity 0.4.19;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    event NewLockProduct(uint indexed lockProductId, uint perTermInterest, uint durationInSecs,\n                            uint minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint indexed lockIndex, uint amountLocked, uint interestEarned,\n                    uint lockedUntil, uint perTermInterest, uint durationInSecs, bool isActive);\n\n    event LockReleased(address indexed lockOwner, uint indexed lockIndex);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint perTermInterest;\n        uint durationInSecs;\n        uint minimumLockAmount;\n        bool isActive;\n    }\n\n    struct Lock {\n        uint amountLocked;\n        uint interestEarned;\n        uint lockedUntil;\n        uint perTermInterest;\n        uint durationInSecs;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n    // per account locks (i.e. an id for a lock is a tuple (owner, index)):\n    mapping(address => Lock[]) public locks;\n\n    function Locker(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor) public {\n\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint perTermInterest, uint durationInSecs, uint minimumLockAmount, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint lockProductId, bool isActive) external restrict(\"MonetaryBoard\") {\n\n        require(lockProductId < lockProducts.length);\n        lockProducts[lockProductId].isActive = isActive;\n        LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    function releaseFunds(address lockOwner, uint lockIndex) external {\n\n        Lock storage lock = locks[lockOwner][lockIndex];\n\n        require(lock.isActive && now >= lock.lockedUntil);\n\n        lock.isActive = false;\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked);   // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lockOwner, lock.amountLocked.add(lock.interestEarned),\n                                                                                \"Funds released from lock\");\n\n        LockReleased(lockOwner, lockIndex);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint[4][20]) {\n\n        uint[4][20] memory response;\n\n        for (uint8 i = 0; i < 20; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs,\n                                        lockProduct.minimumLockAmount, lockProduct.isActive ? 1 : 0 ];\n\n        }\n\n        return response;\n\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n\n        return locks[lockOwner].length;\n\n    }\n\n    // returns 20 locks starting from some offset\n    // lock products are encoded as\n    //              [amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[6][20]) {\n\n        Lock[] storage locksForAddress = locks[lockOwner];\n        uint[6][20] memory response;\n\n        for (uint8 i = 0; i < 20; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locksForAddress[offset + i];\n\n            response[i] = [ lock.amountLocked, lock.interestEarned, lock.lockedUntil, lock.perTermInterest,\n                                        lock.durationInSecs, lock.isActive ? 1 : 0 ];\n\n        }\n\n        return response;\n\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint lockProductId) public {\n        require(msg.sender == address(augmintToken));\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function calculateInterestForLockProduct(uint lockProductId, uint amountToLock) public view returns (uint) {\n\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive);\n        require(amountToLock >= lockProduct.minimumLockAmount);\n\n        uint interestEarned = amountToLock.mul(lockProduct.perTermInterest).div(1000000);\n\n        return interestEarned;\n\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint lockProductId, address lockOwner, uint amountToLock) internal returns (uint) {\n\n        // NB: calculateInterestForLockProduct will validate the lock product and amountToLock:\n        uint interestEarned = calculateInterestForLockProduct(lockProductId, amountToLock);\n\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n\n        uint lockedUntil = now.add(lockProduct.durationInSecs);\n        uint lockIndex = locks[lockOwner].push(Lock(amountToLock, interestEarned, lockedUntil,\n                                                    lockProduct.perTermInterest, lockProduct.durationInSecs, true)) - 1;\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        NewLock(lockOwner, lockIndex, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs, true);\n\n        return interestEarned;\n    }\n\n}\n"
        }
      }
    },
    "c95c1ab8f11cd983deebbe203f4d49be": {
      "latestDeployedAddress": "0xc56757df630980ddcd4e788d0ccf73574a1838ab",
      "deployments": {
        "0xc56757df630980ddcd4e788d0ccf73574a1838ab": {
          "generatedAt": "2018-04-25T12:30:49.440Z",
          "truffleContractFileUpdatedAt": "2018-02-27T07:36:28.125Z",
          "compiler": {
            "name": "solc",
            "version": "0.4.19+commit.c4cbbb05.Emscripten.clang"
          },
          "bytecodeHash": "1ee8107823c445557e111187d4dc2fe1",
          "deployedBytecodeHash": "a90b815047f5c6925b959452739394ee",
          "sourceHash": "d32907ca14fc212ac860efcefb66c83b",
          "source": "/* contract for tracking locked funds etc.\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n    - monetarySupervisor setter?\n\n to do/think about:\n  -> self-destruct function?\n  -> return only active loan products from getLoanProducts?\n*/\n\npragma solidity 0.4.19;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                            uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs, bool isActive);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    function Locker(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor) public {\n\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId);\n        NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"MonetaryBoard\") {\n\n        require(lockProductId < lockProducts.length);\n        lockProducts[lockProductId].isActive = isActive;\n        LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    function releaseFunds(uint lockId) external {\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive);\n        require(now >= lock.lockedUntil);\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        LockReleased(lock.owner, lockId);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint32[4][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs,\n                                        lockProduct.minimumLockAmount, lockProduct.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns CHUNK_SIZE locks starting from some offset\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locks.length) { break; }\n\n            Lock storage lock = locks[offset + i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [uint(offset + i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n    }\n\n    // returns CHUNK_SIZE locks of a given account, starting from some offset\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locks[locksForAddress[offset + i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [ locksForAddress[offset + i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) public {\n        require(msg.sender == address(augmintToken));\n        uint32 lockProductId = uint32(_lockProductId);\n        require(lockProductId == _lockProductId);\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).div(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal returns(uint lockId) {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive);\n        require(amountToLock >= lockProduct.minimumLockAmount);\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration);\n\n        lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs, true);\n    }\n\n}\n"
        }
      }
    },
    "66e3e89133d9bbd91baac5552f21f7e1": {
      "latestDeployedAddress": "0x08f7b3c41b347c6603119412a324f6608194b57f",
      "deployments": {
        "0xe3f2872407243412e4753a77f75eda2269f02da2": {
          "generatedAt": "2018-04-26T14:50:56.210Z",
          "truffleContractFileUpdatedAt": "2018-04-26T14:50:44.242Z",
          "deployTransactionHash": "0x249f764b25cefb3652520d0c3dd3ca20c90c5619c664da5131c396320c213ab2",
          "compiler": {
            "name": "solc",
            "version": "0.4.23+commit.124ca40d.Emscripten.clang"
          },
          "bytecodeHash": "2c6ce8f98482b1d83e432eeb23536574",
          "deployedBytecodeHash": "c0a9aa9f3a0bb633f930f11515b1d0b6",
          "sourceHash": "7ffe14f90465530802dc1f5762e0217f",
          "source": "/* contract for tracking locked funds\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n  -> self-destruct function?\n\n*/\n\npragma solidity ^0.4.23;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                            uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    event MonetarySupervisorChanged(MonetarySupervisor newMonetarySupervisor);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    constructor(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor) public {\n\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId, \"lockProduct overflow\");\n        emit NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"MonetaryBoard\") {\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n\n        lockProducts[lockProductId].isActive = isActive;\n        emit LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n        uint32 lockProductId = uint32(_lockProductId);\n        require(lockProductId == _lockProductId, \"lockProductId overflow\");\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function releaseFunds(uint lockId) external {\n        // next line would revert but require to emit reason:\n        require(lockId < locks.length, \"invalid lockId\");\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive, \"lock must be in active state\");\n        require(now >= lock.lockedUntil, \"current time must be later than lockedUntil\");\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        emit LockReleased(lock.owner, lockId);\n    }\n\n    function setMonetarySupervisor(MonetarySupervisor newMonetarySupervisor) external restrict(\"MonetaryBoard\") {\n        monetarySupervisor = newMonetarySupervisor;\n        emit MonetarySupervisorChanged(newMonetarySupervisor);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, maxLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint[5][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs, lockProduct.minimumLockAmount,\n                        monetarySupervisor.getMaxLockAmount(lockProduct.minimumLockAmount, lockProduct.perTermInterest),\n                        lockProduct.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns CHUNK_SIZE locks starting from some offset\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locks.length) { break; }\n\n            Lock storage lock = locks[offset + i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [uint(offset + i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n    }\n\n    // returns CHUNK_SIZE locks of a given account, starting from some offset\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locks[locksForAddress[offset + i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [ locksForAddress[offset + i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).div(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal returns(uint lockId) {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive, \"lockProduct must be in active state\");\n        require(amountToLock >= lockProduct.minimumLockAmount, \"amountToLock must be >= minimumLockAmount\");\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration, \"lockedUntil overflow\");\n\n        lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        emit NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs);\n    }\n\n}\n"
        },
        "0x664cf487408a31c812fc3e8a875d26bf26b604d8": {
          "generatedAt": "2018-04-30T10:44:44.341Z",
          "truffleContractFileUpdatedAt": "2018-04-30T10:44:29.257Z",
          "deployTransactionHash": "0xef7d363deef3203326294e370f199976b3f3448289267de68051eb3fdc738762",
          "compiler": {
            "name": "solc",
            "version": "0.4.23+commit.124ca40d.Emscripten.clang"
          },
          "bytecodeHash": "2c6ce8f98482b1d83e432eeb23536574",
          "deployedBytecodeHash": "c0a9aa9f3a0bb633f930f11515b1d0b6",
          "sourceHash": "7ffe14f90465530802dc1f5762e0217f",
          "source": "/* contract for tracking locked funds\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n  -> self-destruct function?\n\n*/\n\npragma solidity ^0.4.23;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                            uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    event MonetarySupervisorChanged(MonetarySupervisor newMonetarySupervisor);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    constructor(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor) public {\n\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId, \"lockProduct overflow\");\n        emit NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"MonetaryBoard\") {\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n\n        lockProducts[lockProductId].isActive = isActive;\n        emit LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n        uint32 lockProductId = uint32(_lockProductId);\n        require(lockProductId == _lockProductId, \"lockProductId overflow\");\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function releaseFunds(uint lockId) external {\n        // next line would revert but require to emit reason:\n        require(lockId < locks.length, \"invalid lockId\");\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive, \"lock must be in active state\");\n        require(now >= lock.lockedUntil, \"current time must be later than lockedUntil\");\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        emit LockReleased(lock.owner, lockId);\n    }\n\n    function setMonetarySupervisor(MonetarySupervisor newMonetarySupervisor) external restrict(\"MonetaryBoard\") {\n        monetarySupervisor = newMonetarySupervisor;\n        emit MonetarySupervisorChanged(newMonetarySupervisor);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, maxLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint[5][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs, lockProduct.minimumLockAmount,\n                        monetarySupervisor.getMaxLockAmount(lockProduct.minimumLockAmount, lockProduct.perTermInterest),\n                        lockProduct.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns CHUNK_SIZE locks starting from some offset\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locks.length) { break; }\n\n            Lock storage lock = locks[offset + i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [uint(offset + i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n    }\n\n    // returns CHUNK_SIZE locks of a given account, starting from some offset\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locks[locksForAddress[offset + i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [ locksForAddress[offset + i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).div(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal returns(uint lockId) {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive, \"lockProduct must be in active state\");\n        require(amountToLock >= lockProduct.minimumLockAmount, \"amountToLock must be >= minimumLockAmount\");\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration, \"lockedUntil overflow\");\n\n        lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        emit NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs);\n    }\n\n}\n"
        },
        "0x3444841a0e3417fd486aebc096ef3e67b75d7939": {
          "generatedAt": "2018-05-12T00:22:15.251Z",
          "truffleContractFileUpdatedAt": "2018-05-12T00:22:12.442Z",
          "deployTransactionHash": "0x7d1abed1db9494281c59fa6b7242aed68c8fe109ba641c6714bdb6bd70d30627",
          "compiler": {
            "name": "solc",
            "version": "0.4.23+commit.124ca40d.Emscripten.clang"
          },
          "bytecodeHash": "c6c9a4350153bfd4b81eaf228df169f4",
          "deployedBytecodeHash": "878366e51dfa79329645837646563469",
          "sourceHash": "7ffe14f90465530802dc1f5762e0217f",
          "source": "/* contract for tracking locked funds\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n  -> self-destruct function?\n\n*/\n\npragma solidity ^0.4.23;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                            uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    event MonetarySupervisorChanged(MonetarySupervisor newMonetarySupervisor);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    constructor(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor) public {\n\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"MonetaryBoard\") {\n\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId, \"lockProduct overflow\");\n        emit NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"MonetaryBoard\") {\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n\n        lockProducts[lockProductId].isActive = isActive;\n        emit LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n        uint32 lockProductId = uint32(_lockProductId);\n        require(lockProductId == _lockProductId, \"lockProductId overflow\");\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function releaseFunds(uint lockId) external {\n        // next line would revert but require to emit reason:\n        require(lockId < locks.length, \"invalid lockId\");\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive, \"lock must be in active state\");\n        require(now >= lock.lockedUntil, \"current time must be later than lockedUntil\");\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        emit LockReleased(lock.owner, lockId);\n    }\n\n    function setMonetarySupervisor(MonetarySupervisor newMonetarySupervisor) external restrict(\"MonetaryBoard\") {\n        monetarySupervisor = newMonetarySupervisor;\n        emit MonetarySupervisorChanged(newMonetarySupervisor);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, maxLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint[5][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs, lockProduct.minimumLockAmount,\n                        monetarySupervisor.getMaxLockAmount(lockProduct.minimumLockAmount, lockProduct.perTermInterest),\n                        lockProduct.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns CHUNK_SIZE locks starting from some offset\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locks.length) { break; }\n\n            Lock storage lock = locks[offset + i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [uint(offset + i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n    }\n\n    // returns CHUNK_SIZE locks of a given account, starting from some offset\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locks[locksForAddress[offset + i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [ locksForAddress[offset + i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).div(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal returns(uint lockId) {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive, \"lockProduct must be in active state\");\n        require(amountToLock >= lockProduct.minimumLockAmount, \"amountToLock must be >= minimumLockAmount\");\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration, \"lockedUntil overflow\");\n\n        lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        emit NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs);\n    }\n\n}\n"
        },
        "0x08f7b3c41b347c6603119412a324f6608194b57f": {
          "generatedAt": "2018-05-31T23:56:48.648Z",
          "truffleContractFileUpdatedAt": "2018-05-31T23:54:54.567Z",
          "deployTransactionHash": "0xa8792b8e7ea6f09d5c04575b7479c7fd8bb5387a3ac3227346c796b0f15d47db",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "1d3844fdcfe377c1d77109548d4c03c1",
          "deployedBytecodeHash": "7ecad473f89755346869451c10e0e56a",
          "sourceHash": "45b7822ca3d09ba1a9cb34a0cecc6610",
          "source": "/* contract for tracking locked funds\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n  -> self-destruct function?\n\n*/\n\npragma solidity 0.4.24;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                            uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    event MonetarySupervisorChanged(MonetarySupervisor newMonetarySupervisor);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    constructor(AugmintTokenInterface _augmintToken, MonetarySupervisor _monetarySupervisor) public {\n\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"StabilityBoardSignerContract\") {\n\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId, \"lockProduct overflow\");\n        emit NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"StabilityBoardSignerContract\") {\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n\n        lockProducts[lockProductId].isActive = isActive;\n        emit LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n        uint32 lockProductId = uint32(_lockProductId);\n        require(lockProductId == _lockProductId, \"lockProductId overflow\");\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function releaseFunds(uint lockId) external {\n        // next line would revert but require to emit reason:\n        require(lockId < locks.length, \"invalid lockId\");\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive, \"lock must be in active state\");\n        require(now >= lock.lockedUntil, \"current time must be later than lockedUntil\");\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        emit LockReleased(lock.owner, lockId);\n    }\n\n    function setMonetarySupervisor(MonetarySupervisor newMonetarySupervisor) external restrict(\"StabilityBoardSignerContract\") {\n        monetarySupervisor = newMonetarySupervisor;\n        emit MonetarySupervisorChanged(newMonetarySupervisor);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, maxLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint[5][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs, lockProduct.minimumLockAmount,\n                        monetarySupervisor.getMaxLockAmount(lockProduct.minimumLockAmount, lockProduct.perTermInterest),\n                        lockProduct.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns CHUNK_SIZE locks starting from some offset\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locks.length) { break; }\n\n            Lock storage lock = locks[offset + i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [uint(offset + i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n    }\n\n    // returns CHUNK_SIZE locks of a given account, starting from some offset\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locks[locksForAddress[offset + i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [ locksForAddress[offset + i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).div(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal returns(uint lockId) {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive, \"lockProduct must be in active state\");\n        require(amountToLock >= lockProduct.minimumLockAmount, \"amountToLock must be >= minimumLockAmount\");\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration, \"lockedUntil overflow\");\n\n        lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        emit NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs);\n    }\n\n}\n"
        }
      }
    },
    "619ff7809b73aead28176fe6317953c3": {
      "latestDeployedAddress": "0x26b4ababb98fcadd579f28e9c30931bbbe66fc88",
      "deployments": {
        "0x26b4ababb98fcadd579f28e9c30931bbbe66fc88": {
          "generatedAt": "2018-08-14T19:51:18.170Z",
          "truffleContractFileUpdatedAt": "2018-08-14T19:50:59.304Z",
          "deployTransactionHash": "0xf20bcb8da89378ff7e87984323ceadd194f077400aa2814076f904a78e311061",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "d70fd016b0dd90d831c6fa598f5db895",
          "deployedBytecodeHash": "53ea6691d90091a48438f4e80961c2f7",
          "sourceHash": "0bc34f96859842d6cde3876ee878a209",
          "source": "/* contract for tracking locked funds\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n  -> self-destruct function?\n\n*/\n\npragma solidity 0.4.24;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    uint public constant CHUNK_SIZE = 100;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                            uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    event MonetarySupervisorChanged(MonetarySupervisor newMonetarySupervisor);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken,\n                    MonetarySupervisor _monetarySupervisor)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"StabilityBoard\") {\n\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId, \"lockProduct overflow\");\n        emit NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"StabilityBoard\") {\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n\n        lockProducts[lockProductId].isActive = isActive;\n        emit LockProductActiveChange(lockProductId, isActive);\n\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n        uint32 lockProductId = uint32(_lockProductId);\n        require(lockProductId == _lockProductId, \"lockProductId overflow\");\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function releaseFunds(uint lockId) external {\n        // next line would revert but require to emit reason:\n        require(lockId < locks.length, \"invalid lockId\");\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive, \"lock must be in active state\");\n        require(now >= lock.lockedUntil, \"current time must be later than lockedUntil\");\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        emit LockReleased(lock.owner, lockId);\n    }\n\n    function setMonetarySupervisor(MonetarySupervisor newMonetarySupervisor) external restrict(\"StabilityBoard\") {\n        monetarySupervisor = newMonetarySupervisor;\n        emit MonetarySupervisorChanged(newMonetarySupervisor);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n\n        return lockProducts.length;\n\n    }\n\n    // returns 20 lock products starting from some offset\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, maxLockAmount, isActive ]\n    function getLockProducts(uint offset) external view returns (uint[5][CHUNK_SIZE] response) {\n        for (uint8 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= lockProducts.length) { break; }\n\n            LockProduct storage lockProduct = lockProducts[offset + i];\n\n            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs, lockProduct.minimumLockAmount,\n                        monetarySupervisor.getMaxLockAmount(lockProduct.minimumLockAmount, lockProduct.perTermInterest),\n                        lockProduct.isActive ? 1 : 0 ];\n        }\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns CHUNK_SIZE locks starting from some offset\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locks.length) { break; }\n\n            Lock storage lock = locks[offset + i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [uint(offset + i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n    }\n\n    // returns CHUNK_SIZE locks of a given account, starting from some offset\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n\n        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n\n            if (offset + i >= locksForAddress.length) { break; }\n\n            Lock storage lock = locks[locksForAddress[offset + i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i] = [ locksForAddress[offset + i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).ceilDiv(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal returns(uint lockId) {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive, \"lockProduct must be in active state\");\n        require(amountToLock >= lockProduct.minimumLockAmount, \"amountToLock must be >= minimumLockAmount\");\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration, \"lockedUntil overflow\");\n\n        lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        emit NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs);\n    }\n\n}\n"
        }
      }
    },
    "f59526398823aef0f0c1454d0b6b4eac": {
      "latestDeployedAddress": "0x26b4ababb98fcadd579f28e9c30931bbbe66fc88",
      "deployments": {
        "0x26b4ababb98fcadd579f28e9c30931bbbe66fc88": {
          "generatedAt": "2018-10-18T13:35:02.423Z",
          "truffleContractFileUpdatedAt": "2018-10-18T11:36:36.960Z",
          "deployTransactionHash": "0xc7c614d66a755c9a7e1046a3eb03fb9caa64606d726368532dfea3de500bf2ba",
          "compiler": {
            "name": "solc",
            "version": "0.4.24+commit.e67f0147.Emscripten.clang"
          },
          "bytecodeHash": "0fe102ad0cf754658fdb075cb2850270",
          "deployedBytecodeHash": "211e0b56eb9155bf091df2937a90551d",
          "sourceHash": "5fb19771489eecebfa02e95214887146",
          "source": "/* contract for tracking locked funds\n\n requirements\n  -> lock funds\n  -> unlock funds\n  -> index locks by address\n\n For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n\n TODO / think about:\n  -> self-destruct function?\n\n*/\n\npragma solidity 0.4.24;\n\nimport \"./generic/Restricted.sol\";\nimport \"./generic/SafeMath.sol\";\nimport \"./interfaces/AugmintTokenInterface.sol\";\nimport \"./MonetarySupervisor.sol\";\nimport \"./interfaces/TokenReceiver.sol\";\n\n\ncontract Locker is Restricted, TokenReceiver {\n\n    using SafeMath for uint256;\n\n    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n                    uint32 minimumLockAmount, bool isActive);\n\n    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n\n    // NB: amountLocked includes the original amount, plus interest\n    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs);\n\n    event LockReleased(address indexed lockOwner, uint lockId);\n\n    event MonetarySupervisorChanged(MonetarySupervisor newMonetarySupervisor);\n\n    struct LockProduct {\n        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n        uint32 perTermInterest;\n        uint32 durationInSecs;\n        uint32 minimumLockAmount;\n        bool isActive;\n    }\n\n    /* NB: we don't need to store lock parameters because lockProducts can't be altered (only disabled/enabled) */\n    struct Lock {\n        uint amountLocked;\n        address owner;\n        uint32 productId;\n        uint40 lockedUntil;\n        bool isActive;\n    }\n\n    AugmintTokenInterface public augmintToken;\n    MonetarySupervisor public monetarySupervisor;\n\n    LockProduct[] public lockProducts;\n\n    Lock[] public locks;\n\n    // lock ids for an account\n    mapping(address => uint[]) public accountLocks;\n\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken,\n                    MonetarySupervisor _monetarySupervisor)\n    public Restricted(permissionGranterContract) {\n        augmintToken = _augmintToken;\n        monetarySupervisor = _monetarySupervisor;\n\n    }\n\n    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n    external restrict(\"StabilityBoard\") {\n        uint _newLockProductId = lockProducts.push(\n                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n        uint32 newLockProductId = uint32(_newLockProductId);\n        require(newLockProductId == _newLockProductId, \"lockProduct overflow\");\n        emit NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n    }\n\n    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict(\"StabilityBoard\") {\n        // next line would revert but require to emit reason:\n        require(lockProductId < lockProducts.length, \"invalid lockProductId\");\n\n        lockProducts[lockProductId].isActive = isActive;\n        emit LockProductActiveChange(lockProductId, isActive);\n    }\n\n    /* lock funds, called from AugmintToken's transferAndNotify\n     Flow for locking tokens:\n        1) user calls token contract's transferAndNotify lockProductId passed in data arg\n        2) transferAndNotify transfers tokens to the Lock contract\n        3) transferAndNotify calls Lock.transferNotification with lockProductId\n    */\n    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external {\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\n        // next line would revert but require to emit reason:\n        require(_lockProductId < lockProducts.length, \"invalid lockProductId\");\n        uint32 lockProductId = uint32(_lockProductId);\n        /* TODO: make data arg generic bytes\n            uint productId;\n            assembly { // solhint-disable-line no-inline-assembly\n                productId := mload(data)\n        } */\n        _createLock(lockProductId, from, amountToLock);\n    }\n\n    function releaseFunds(uint lockId) external {\n        // next line would revert but require to emit reason:\n        require(lockId < locks.length, \"invalid lockId\");\n        Lock storage lock = locks[lockId];\n        LockProduct storage lockProduct = lockProducts[lock.productId];\n\n        require(lock.isActive, \"lock must be in active state\");\n        require(now >= lock.lockedUntil, \"current time must be later than lockedUntil\");\n\n        lock.isActive = false;\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n                                                                                \"Funds released from lock\");\n\n        emit LockReleased(lock.owner, lockId);\n    }\n\n    function setMonetarySupervisor(MonetarySupervisor newMonetarySupervisor) external restrict(\"StabilityBoard\") {\n        monetarySupervisor = newMonetarySupervisor;\n        emit MonetarySupervisorChanged(newMonetarySupervisor);\n    }\n\n    function getLockProductCount() external view returns (uint) {\n        return lockProducts.length;\n    }\n\n    // returns <chunkSize> lock products starting from some <offset>\n    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, maxLockAmount, isActive ]\n    function getLockProducts(uint offset, uint16 chunkSize)\n    external view returns (uint[5][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), lockProducts.length);\n        uint[5][] memory response = new uint[5][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            LockProduct storage lockProduct = lockProducts[i];\n            response[i - offset] = [lockProduct.perTermInterest, lockProduct.durationInSecs, lockProduct.minimumLockAmount,\n                        monetarySupervisor.getMaxLockAmount(lockProduct.minimumLockAmount, lockProduct.perTermInterest),\n                        lockProduct.isActive ? 1 : 0 ];\n        }\n        return response;\n    }\n\n    function getLockCount() external view returns (uint) {\n        return locks.length;\n    }\n\n    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n        return accountLocks[lockOwner].length;\n    }\n\n    // returns <chunkSize> locks starting from some <offset>\n    // lock products are encoded as\n    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n    function getLocks(uint offset, uint16 chunkSize)\n    external view returns (uint[8][]) {\n        uint limit = SafeMath.min(offset.add(chunkSize), locks.length);\n        uint[8][] memory response = new uint[8][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            Lock storage lock = locks[i];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i - offset] = [uint(i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n                        lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n        }\n        return response;\n    }\n\n    // returns <chunkSize> locks of a given account, starting from some <offset>\n    // lock products are encoded as\n    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n    function getLocksForAddress(address lockOwner, uint offset, uint16 chunkSize)\n    external view returns (uint[7][]) {\n        uint[] storage locksForAddress = accountLocks[lockOwner];\n        uint limit = SafeMath.min(offset.add(chunkSize), locksForAddress.length);\n        uint[7][] memory response = new uint[7][](limit.sub(offset));\n\n        for (uint i = offset; i < limit; i++) {\n            Lock storage lock = locks[locksForAddress[i]];\n            LockProduct storage lockProduct = lockProducts[lock.productId];\n\n            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n\n            response[i - offset] = [locksForAddress[i], lock.amountLocked, interestEarned, lock.lockedUntil,\n                        lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n        }\n        return response;\n    }\n\n    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n        interestEarned = amountToLock.mul(perTermInterest).ceilDiv(1000000);\n    }\n\n    // Internal function. assumes amountToLock is already transferred to this Lock contract\n    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal {\n        LockProduct storage lockProduct = lockProducts[lockProductId];\n        require(lockProduct.isActive, \"lockProduct must be in active state\");\n        require(amountToLock >= lockProduct.minimumLockAmount, \"amountToLock must be >= minimumLockAmount\");\n\n        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n        uint expiration = now.add(lockProduct.durationInSecs);\n        uint40 lockedUntil = uint40(expiration);\n        require(lockedUntil == expiration, \"lockedUntil overflow\");\n\n        uint lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n        accountLocks[lockOwner].push(lockId);\n\n        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n\n        emit NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n                    lockProduct.durationInSecs);\n    }\n}\n"
        }
      }
    }
  }
}